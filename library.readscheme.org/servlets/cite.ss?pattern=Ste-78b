<html><head><title>Citation: RABBIT: A Compiler for SCHEME</title><link rel="stylesheet" href="../basic.css" type="text/css" /></head><body bgcolor="white"><table width="100%"><tr valign="top"><td width="124"><table width="124"><tr width="124" height="45"><td width="124" height="45"><a href="http://readscheme.org"><img width="124" height="45" border="0" alt="Readscheme.org" src="../nav-logo.gif" /></a></td></tr><tr width="124" height="124"><td width="124" height="124"><a href="../index.html" target="_top"><img width="124" height="124" border="0" alt="Scheme Bibliography Home" src="../nav_mainlogo.gif" /></a></td></tr><tr width="124" height="30"><td width="124" height="30"><a href="../page1.html" target="_top"><img width="124" height="30" border="0" alt="Classics" src="../nav_classics.gif" /></a></td></tr><tr width="124" height="18"><td width="124" height="18"><a href="../page2.html" target="_top"><img width="124" height="18" border="0" alt="Semantics" src="../nav_sem.gif" /></a></td></tr><tr width="124" height="18"><td width="124" height="18"><a href="../page3.html" target="_top"><img width="124" height="18" border="0" alt="Macros" src="../nav_macros.gif" /></a></td></tr><tr width="124" height="18"><td width="124" height="18"><a href="../page4.html" target="_top"><img width="124" height="18" border="0" alt="Objects" src="../nav_objects.gif" /></a></td></tr><tr width="124" height="30"><td width="124" height="30"><a href="../page5.html" target="_top"><img width="124" height="30" border="0" alt="Modules" src="../nav_modules.gif" /></a></td></tr><tr width="124" height="18"><td width="124" height="18"><a href="../page6.html" target="_top"><img width="124" height="18" border="0" alt="Continuations" src="../nav_cps.gif" /></a></td></tr><tr width="124" height="30"><td width="124" height="30"><a href="../pagexml.html" target="_top"><img width="124" height="30" border="0" alt="Web Programming" src="../nav_xml.gif" /></a></td></tr><tr width="124" height="18"><td width="124" height="18"><a href="../page7.html" target="_top"><img width="124" height="18" border="0" alt="Applications" src="../nav_appl.gif" /></a></td></tr><tr width="124" height="18"><td width="124" height="18"><a href="../page8.html" target="_top"><img width="124" height="18" border="0" alt="Implementation" src="../nav_impl.gif" /></a></td></tr><tr width="124" height="30"><td width="124" height="30"><a href="../page9.html" target="_top"><img width="124" height="30" border="0" alt="Concurrent Programming" src="../nav_conc.gif" /></a></td></tr><tr width="124" height="30"><td width="124" height="30"><a href="../page10.html" target="_top"><img width="124" height="30" border="0" alt="Partial Evaluation" src="../nav_pe.gif" /></a></td></tr><tr width="124" height="18"><td width="124" height="18"><a href="../page11.html" target="_top"><img width="124" height="18" border="0" alt="Reflection" src="../nav_reflect.gif" /></a></td></tr><tr width="124" height="30"><td width="124" height="30"><a href="../whats_new.html" target="_top"><img width="124" height="30" border="0" alt="Recent Additions" src="../nav_recent.gif" /></a></td></tr><tr width="124" height="30"><td width="124" height="30"><a href="../browse.html" target="_top"><img width="124" height="30" border="0" alt="Browse by Author" src="../nav_browse.gif" /></a></td></tr><tr width="124" height="18"><td width="124" height="18"><a href="../search.html" target="_top"><img width="124" height="18" border="0" alt="Search..." src="../nav_search.gif" /></a></td></tr></table></td><td width="20"><img width="20" height="1" border="0" src="../imgs/dot_clear.gif" /></td><td><h2>RABBIT: A Compiler for SCHEME</h2><h3>Guy Lewis Steele, Jr.</h3><p><u>Abstract:</u></p><p>We have developed a compiler for the lexically-scoped dialect of LISP known as SCHEME. The compiler knows relatively little about specific data manipulation primitives such as arithmetic operators, but concentrates on general issues of environment and control. Rather than having specialized knowledge about a large variety of control and environment constructs, the compiler handles only a small basis set which reflects the semantics of lambda- calculus. All of the traditional imperative constructs, such as sequencing, assignment, looping, GOTO, as well as many standard LISP constructs such as AND, OR, and COND, are expressed in macros in terms of the applicative basis set. A small number of optimization techniques, coupled with the treatment of function calls as GOTO statements, serve to produce code as good as that produced by more traditional compilers. The macro approach enables speedy implementation of new constructs as desired without sacrificing efficiency in the generated code. A fair amount of analysis is devoted to determining whether environments may be stack-allocated or must be heap- allocated. Heap-allocated environments are necessary in general because SCHEME (unlike Algol 60 and Algol 68, for example) allows procedures with free lexically scoped variables to be returned as the values of other procedures; the Algol stack-allocation environment strategy does not suffice. The methods used here indicate that a heap- allocating generalization of the "display" technique leads to an efficient implementation of such "upward funargs". Moreover, compile- time optimization and analysis can eliminate many "funargs" entirely, and so far fewer environment structures need be allocated at run time than might be expected. A subset of SCHEME (rather than triples, for example) serves as the representation intermediate between the optimized SCHEME code and the final output code; code is expressed in this subset in the so-called continuation-passing style. As a subset of SCHEME, it enjoys the same theoretical properties; one could even apply the same optimizer used on the input code to the intermediate code. However, the subset is so chosen that all temporary quantities are made manifest as variables, and no control stack is needed to evaluate it. As a result, this apparently applicative representation admits an imperative interpretation which permits easy transcription to final imperative machine code. These qualities suggest that an applicative language like SCHEME is a better candidate for an UNCOL than the more imperative candidates proposed to date.</p><p><u>Downloads:</u></p><ul><li><a href="http://repository.readscheme.org/ftp/papers/ai-lab-pubs/AITR-474.ps.gz">ps</a></li><li><a href="http://repository.readscheme.org/ftp/papers/ai-lab-pubs/AITR-474.pdf">pdf</a></li></ul><p><u>Bibtex citation:</u></p><pre>@mastersthesis{
   key = "Ste:78b"
   author = "Guy Lewis Steele, Jr."
   title = "RABBIT: A Compiler for SCHEME"
   number = "AI Lab Technical Report AITR-474"
   school = "MIT AI Lab"
   month = "May"
   year = "1978"
   url = "http://repository.readscheme.org/ftp/papers/ai-lab-pubs/AITR-474.ps.gz"
   url = "http://repository.readscheme.org/ftp/papers/ai-lab-pubs/AITR-474.pdf"
}
</pre></td></tr></table></body></html>